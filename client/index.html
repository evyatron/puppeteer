<!doctype html>
<html lang="en">
  <head>
    <title>Puppeteerer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <style>
      body, div, h2, ul, li, canvas {
        margin: 0;
        padding: 0;
      }
      
      body {
        -webkit-user-select: none;
        overflow: hidden;
      }
      
      canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background: linear-gradient(to bottom, #a0f0ff, #70d0df);
      }
      #game {
        position: relative;
        padding: 5px;
        font-size: .9em;
        z-index: 10;
      }
      h2 {
        font-size: 1.1em;
        margin-bottom: 10px;
      }
      a {
        color: inherit;
      }
      .error {
        padding: 8px;
        color: #fff;
        background: #600;
      }
      .calibrate {
        position: absolute;
        bottom: 0;
        right: 0;
        padding: 10px;
        background: linear-gradient(to bottom, #ddd, #aaa);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, .3) inset;
        border-top: 1px solid #999;
        border-left: 1px solid #999;
        border-radius: 5px 0 0 0;
      }
      .calibrate:active {
        background: linear-gradient(to bottom, #bbb, #888);
      }
    </style>
    <script>
      /*
        global io
      */
      var Client = (function Client() {
        function Client(options) {
          this.el;
          this.localPuppetEl;
          this.isController = false;
          this.isView = false;
          
          this.socket;
          
          this.canvas;
          this.context;
          this.lastUpdate = 0;
          this.dt = 0;
          
          this.possessedPuppetId;
          this.localPuppet;
          this.baseLine = {};
          this.sensorFreq = 0.06;
          this.timeToReportSensor = this.sensorFreq;
          this.sensorData = {
            'alpha': 0,
            'beta': 0
          };
          
          this.isWaitingOnPlayers = false;

          this.puppets = {};
          
          this.angleLerpAlpha = 0.5;
          this.mouthLerpAlpha = 0.5;
          this.mouthOpenPercent = 0.4;
          this.maxMouthAngle = 10;
          this.backMouthWidth = 0.5;
          
          this.timeForTap = 150;
          this.sensorAlpha = 0.7;
          
          this.myPuppet = {};
          
          this.init(options);
        }
        
        Client.prototype.init = function init(options) {
          !options && (options = {});
          
          this.el = options.el || document.body;
          this.socket = io.connect();
          
          this.canvas = document.createElement('canvas');
          this.context = this.canvas.getContext('2d');
          this.el.appendChild(this.canvas);
          
          this.lastUpdate = Date.now();
          window.requestAnimationFrame(this.tick.bind(this));
          
          document.querySelector('.calibrate').addEventListener('click', this.calibrate.bind(this));
          
          this.socket.on('connect', this.connect.bind(this));
          this.socket.on('listGamesToClient', this.listGamesToClient.bind(this));
          this.socket.on('errorToClient', this.errorToClient.bind(this));
        };
        
        Client.prototype.connect = function connect(data) {
          var gameId = window.location.search.replace('?', '');
          
          this.socket.on('gameInfoToClient', this.gameInfoToClient.bind(this));
          this.socket.on('gamePuppetsToClient', this.gamePuppetsToClient.bind(this));
          
          if ('ontouchstart' in window) {
            this.startAsController(gameId);
          } else {
            this.startAsView(gameId);
          }
          
          if (gameId) {
            this.socket.emit('connectToGameFromClient', {
              'gameId': gameId
            });
          }
        };
        
        Client.prototype.errorToClient = function errorToClient(data) {
          var html = '<div class="error">' +
                        data.message + '<br />' +
                        '<a href="/">Go back to create a new one</a>' +
                      '</div>';
          
          document.getElementById('game').innerHTML = html;
        };
        
        Client.prototype.listGamesToClient = function listGamesToClient(data) {
          var games = data.games;
          var html = '<h2>Please select from one of the active games:</h2>';
          
          for (var id in games) {
            var game = games[id];
            var url = 'http://' + window.location.host + '/?' + id;
            var numPuppets = Object.keys(game.puppets).length;
            var numPlayers = game.playerIds.length;
            
            html += '<div>' +
                      '<a href="' + url + '">' + url + '</a> - ' + 
                      (numPlayers - numPuppets) + ' viewers, ' +
                      numPuppets + ' puppets' +
                    '</div>';
          }
          
          document.getElementById('game').innerHTML = html;
        };
        
        Client.prototype.startAsView = function startAsView(gameId) {
          console.warn('Start as view');
          
          this.isController = false;
          this.isView = true;
          
          this.socket.on('removePlayerToClient', this.removePlayerToClient.bind(this));
          this.socket.on('removePuppetToClient', this.removePuppetToClient.bind(this));
          
          window.addEventListener('resize', this.onResize.bind(this));
          
          if (!gameId) {
            this.socket.emit('createGameFromClient', {
              'width': window.innerWidth,
              'height': window.innerHeight
            });
          }
        };
        
        Client.prototype.startAsController = function startAsController(gameId) {
          console.warn('Start as controller', gameId);
          
          if (!gameId) {
            this.socket.emit('listGamesFromClient');
            return;
          }
          
          this.socket.on('resizeGameToClient', this.setSize.bind(this));
          this.socket.on('possessPuppetToClient', this.possessPuppetToClient.bind(this));
          this.canvas.addEventListener('touchstart', this.onTouchStart.bind(this));
          this.canvas.addEventListener('touchmove', this.onTouchMove.bind(this));
          this.canvas.addEventListener('touchend', this.onTouchEnd.bind(this));
          
          this.isController = true;
          this.isView = false;
          
          window.addEventListener('deviceorientation', function (e){
            this.sensorData.alpha = e.alpha;
            this.sensorData.beta = e.beta;
          }.bind(this));
          
          this.calibrate();
        };
        
        Client.prototype.possessPuppetToClient = function possessPuppetToClient(data) {
          console.warn('possessPuppetToClient', data.puppetId);
          this.possessedPuppetId = data.puppetId;
        };
        
        Client.prototype.calibrate = function calibrate() {
          if (Math.abs(this.sensorData.beta) > 25) {
            this.baseLine.beta = 70;
          }
        };
        
        Client.prototype.sendMovement = function sendMovement() {
          for (var k in this.baseLine) {
            this.sensorData[k] -= this.baseLine[k];
          }
  
          this.socket.emit('movementFromClient', this.sensorData);
        };
        
        Client.prototype.tick = function tick() {
          var now = Date.now();
          this.dt = (now - this.lastUpdate) / 1000;
          
          if (this.isController) {
            this.timeToReportSensor -= this.dt;
            if (this.timeToReportSensor <= 0) {
              this.timeToReportSensor = this.sensorFreq;
              this.sendMovement();
            }
          }
          
          var context = this.context;
          var maxMouthOpen = this.mouthOpenPercent;
          var backMouthWidth = this.backMouthWidth;
          
          context.clearRect(0, 0, this.width, this.height);

          for (var id in this.puppets) {
            var puppet = this.puppets[id];

            puppet.targetAngle = puppet.movementData.alpha || 0;
            puppet.targetMouthOpen = Math.max(Math.min((-puppet.movementData.beta || 0) / this.maxMouthAngle, 1), 0);

            puppet.angle += (puppet.targetAngle - puppet.angle) * this.angleLerpAlpha;
            puppet.mouthOpen += (puppet.targetMouthOpen - puppet.mouthOpen) * this.mouthLerpAlpha;
            
            var ratio = this.ratio;
            var x = puppet.x * this.width;
            var y = puppet.y * this.height;
            var w = puppet.width * ratio;
            var h = puppet.height * ratio;
            var hw = w / 2;
            var hh = h / 2;
            var mouthDist = puppet.mouthOpen * h * maxMouthOpen;
            
            if (id === this.possessedPuppetId) {
              this.myPuppet = {
                'top': y - hh,
                'bottom': y + hh,
                'left': x - hw,
                'right': x + hw
              };
            }
            
            context.save();
            
            context.translate(x, y);
            context.rotate(puppet.angle * Math.PI / 180);
            
            if (puppet.isFlipped) {
              context.scale(-1, 1);
            }
            
            // body
            context.fillStyle = puppet.colour;
            context.fillRect(-hw, -hh, w, h * 0.8);
            // mouth
            context.fillRect(-hw, -hh + h * 0.8 - 1, w * backMouthWidth, mouthDist);
            context.fillRect(-hw, -hh + h * 0.8 + mouthDist - 2, w, h * 0.2);
            // eye
            context.fillStyle = 'rgba(255, 255, 255, 1)';
            context.beginPath();
            context.arc(-hw + w * 0.85, -hh + h * 0.2, 14 * ratio, 0, Math.PI * 180);
            context.fill();
            //context.fillRect(-hw + w * 0.85, -hh + h * 0.2, w / 10, h / 10);
            context.fillStyle = 'rgba(0, 0, 0, 1)';
            context.beginPath();
            context.arc(-hw + w * 0.87, -hh + h * 0.21, 5 * ratio, 0, Math.PI * 180);
            context.fill();
            //context.fillRect(-hw + w * 0.89, -hh + h * 0.24, w / 30, h / 30);
            
            context.restore();
          }
          
          this.lastUpdate = now;
          window.requestAnimationFrame(this.tick.bind(this));
        };
        
        Client.prototype.gameInfoToClient = function gameInfoToClient(data) {
          var game = data.game;
          
          var urlGameId = window.location.search.replace('?', '');
          if (urlGameId !== game.id) {
            window.history.pushState('', '', '?' + game.id);
          }
          
          console.warn('Got game info', game);
          
          this.setSize({
            'width': game.width,
            'height': game.height
          });

          if (this.isController) {
            document.getElementById('game').innerHTML = 'Connected to game';
            
            this.calibrate();
            
            this.socket.emit('addPuppetFromClient', {
              'type': 'default',
              'name': 'My Puppet'
            });
          } else if (this.isView) {
            if (game.numberOfPuppets === 0) {
              this.isWaitingOnPlayers = true;
              document.getElementById('game').innerHTML = 'Waiting for players to join...' +
                                                          '<br />' +
                                                          'Please open this link on your mobile device' +
                                                          '<br />' +
                                                          '<img src="' + game.qr + '" />';
            }
          }
        };
        
        Client.prototype.addNewPuppet = function addNewPuppet(puppet) {
          console.warn('addNewPuppet', puppet);
          
          this.puppets[puppet.id] = puppet;
          
          puppet.targetAngle = puppet.angle = -puppet.movementData.alpha || 0;
          puppet.targetMouthOpen = puppet.mouthOpen = Math.max(Math.min((-puppet.movementData.beta || 0) / this.maxMouthAngle, 1), 0);
        };
        
        Client.prototype.gamePuppetsToClient = function gamePuppetsToClient(puppets) {
          var puppetId;
          
          for (puppetId in puppets) {
            if (this.puppets[puppetId]) {
              this.puppets[puppetId].isFlipped = puppets[puppetId].isFlipped;
              this.puppets[puppetId].x = puppets[puppetId].x;
              this.puppets[puppetId].y = puppets[puppetId].y;
              this.puppets[puppetId].movementData = puppets[puppetId].movementData;
            } else {
              this.addNewPuppet(puppets[puppetId]);
            }
          }
          
          for (puppetId in this.puppets) {
            if (!puppets[puppetId]) {
              delete this.puppets[puppetId];
            }
          }
          
          if (this.isWaitingOnPlayers && Object.keys(puppets).length > 0) {
            this.isWaitingOnPlayers = false;
            document.getElementById('game').innerHTML = '';
          }
        };
        
        Client.prototype.removePlayerToClient = function removePlayerToClient(data) {
          console.warn('...removeplayer...');
        };
        
        Client.prototype.removePuppetToClient = function removePuppetToClient(puppetId) {
          this.puppets[puppetId] = null;
          delete this.puppets[puppetId];
        };
        
        Client.prototype.onResize = function onResize() {
          if (this.isView) {
            var size = {
              'width': window.innerWidth,
              'height': window.innerHeight
            };
            
            this.socket.emit('resizeGameFromClient', size);
            this.setSize(size);
          }
        };
        
        Client.prototype.setSize = function setSize(data) {
          this.ratio = Math.min(window.innerWidth / data.width, window.innerHeight / data.height);
          
          this.canvas.width = this.width = data.width * this.ratio;
          this.canvas.height = this.height = data.height * this.ratio;
          this.canvas.style.marginTop = -this.height / 2 + 'px';
          this.canvas.style.marginLeft = -this.width / 2 + 'px';
          this.canvas.style.width = this.width + 'px';
          this.canvas.style.height = this.height + 'px';
        };
        
        Client.prototype.getPossessedPuppet = function getPossessedPuppet() {
          return this.puppets[this.possessedPuppetId] || {};
        };
        
        Client.prototype.onTouchStart = function onTouchStart(e) {
          e.preventDefault();
          
          if (this.touchStart) {
            return;
          }
          
          var x = e.touches[0].pageX - this.canvas.offsetLeft;
          var y = e.touches[0].pageY - this.canvas.offsetTop;

          if (x > this.myPuppet.left && x < this.myPuppet.right &&
              y > this.myPuppet.top && y < this.myPuppet.bottom) {
                
            var localPuppet = this.getPossessedPuppet();
            this.touchStart = {
              'when': Date.now(),
              'x': x - localPuppet.x * this.width,
              'y': y - localPuppet.y * this.height
            };
          } else {
            this.touchStart = null;
          }
        };
        
        Client.prototype.onTouchMove = function onTouchMove(e) {
          if (!this.touchStart) {
            return;
          }
          
          var touch = e.changedTouches[0];
          var x = (touch.pageX - this.canvas.offsetLeft - this.touchStart.x) / this.width;
          var y = (touch.pageY - this.canvas.offsetTop - this.touchStart.y) / this.height;
          
          x = Math.max(Math.min(x, 1), 0);
          y = Math.max(Math.min(y, 1), 0);

          this.socket.emit('positionFromClient', {
            'x': x,
            'y': y
          });
        };
        
        Client.prototype.onTouchEnd = function onTouchEnd(e) {
          if (!this.touchStart) {
            return;
          }

          if (Date.now() - this.touchStart.when <= this.timeForTap) {
            var localPuppet = this.getPossessedPuppet();
            localPuppet.isFlipped = !localPuppet.isFlipped;
            
            this.socket.emit('flipPuppetFromClient');
          }
          
          this.touchStart = null;
        };
        
        return Client;
      }());
    </script>
  </head>
  <body>
    <div id="game"></div>
    <div id="container"></div>
    <div class="calibrate">Calibrate (press when phone is upright)</div>
    
    <script src="/socket.io/socket.io.js"></script>
    
    <script>
      var client = new Client({
        'el': document.getElementById('container')
      });
    </script>
  </body>
</html>
